#!/bin/bash

set -e
# set -x

if [[ -z "$BUILD" ]]; then
  echo "Error: BUILD variable is not set."
  exit 1
fi

INITIAL_SET_E_STATUS=0
case "$-" in *e*) INITIAL_SET_E_STATUS=1 ;; esac  # check if -e is set and save the status


VERSION="${VERSION:-$(echo ${GITHUB_REF} | sed -e 's|refs/heads/||' -e 's|refs/tags/||' -e 's|/|-|g')}"
OS="${BUILD:-$(uname)}"  # uname returns the OS name, e.g. Linux, Darwin, etc. !!! Linux !- linux lowercase
ARCH="$(uname -m)"

### *** GPG KEY SETUP ***

# Listing GPG keys:
#     gpg --list-keys          or   gpg -k
#     gpg --list-secret-keys   or   gpg -K
# Removing keys:
#   gpg --delete-key           or   gpg --delete-secret-key
#   just simply delete directory ~/.gnupg - this will remove all keys, make backup first

# Set the GPG key name for RPM packages
# Guaranteed invalid email address for temporary key @invalid.com
GPG_KEY_NAME="Temporary Inkstitch Build Key (Automated CI/CD Only) <inkstitch@invalid.com>"
# Initial GPG Key ID - in main branch secrets.
# This will be updated if a new key is generated.
GPG_KEY_ID="EA93BCE2CCD0FB2E77B2CC29E8120E50709E5C44"

# Function to generate a new GPG key
function generate_gpg_key() {
    echo "INKSTITCH_GPG_KEY variable is not set. Generating a new GPG key..."
    gpg --batch --full-generate-key <<EOF
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: $GPG_KEY_NAME
Name-Comment: Temporary RPM Signing Key for Ink/Stitch
Name-Email: inkstitch@invalid.com
Expire-Date: 0
%no-protection
%commit
EOF
    echo "New GPG key has been generated."
}

# This function retrieves the ID of the temporary GPG key. Sear local GPG keyring for the key.
function get_gpg_key_id() {
    # Get the ID of the temporary key
    GENERATED_KEY_ID=$(gpg --list-secret-keys --with-colons "$GPG_KEY_NAME" | awk -F: '/^sec/{print $5; exit}')

    if [ -z "$GENERATED_KEY_ID" ]; then
        echo "Error: Failed to retrieve the ID of the temporary GPG key."
        exit 1
    fi

    # Update GPG_KEY_ID to match the newly generated key
    GPG_KEY_ID=$GENERATED_KEY_ID
    echo "Generated key ID: $GPG_KEY_ID"
}

# Retrieve the GPG key ID in variable GPG_KEY_ID
# This function checks if the INKSTITCH_GPG_KEY variable is set.
#   If it is not set, it checks for an existing key and generates a new one if necessary.
#   If the variable is set, it imports the key from the variable.
function retrieve_gpg_key_id() {
    # Check if INKSTITCH_GPG_KEY is set
    if [ -z "$INKSTITCH_GPG_KEY" ]; then  # If not set, we will generate a new GPG key
        # try to get the key ID of the existing local temporary key

        if [ $INITIAL_SET_E_STATUS -eq 1 ]; then   # temporary disable -e if it was set
            set +e
        fi

        gpg --list-secret-keys --keyid-format LONG "$GPG_KEY_NAME" &>/dev/null
        GPG_STATUS=$?

        if [ $INITIAL_SET_E_STATUS -eq 1 ]; then   # restore -e if it was set
            set -e
        fi


        if [[ $GPG_STATUS -eq 0 ]]; then
            echo "Found existing GPG key for user ID: $GPG_KEY_NAME"
            get_gpg_key_id  # Update GPG_KEY_ID to the existing key ID
        else
            echo "No existing GPG key found. Generating a new GPG key..."
            generate_gpg_key
            get_gpg_key_id  # Update GPG_KEY_ID after generating a new key
        fi

        echo "GPG key ID is set to: $GPG_KEY_ID"

    else  # If INKSTITCH_GPG_KEY is set, import the key from the variable
        echo "Importing GPG key from INKSTITCH_GPG_KEY variable..."
        echo "$INKSTITCH_GPG_KEY" | base64 -d | gpg --import  # import to local GPG keyring
        echo "GPG key has been imported."
    fi
}


### Start of the script

if [ "$BUILD" = "osx" ]; then
    cp -a addons icons locales print LICENSE VERSION palettes symbols fonts tiles dbus inx dist/inkstitch.app/Contents/Resources
    # adding version to Info.plist
    plutil -replace CFBundleShortVersionString -string ${VERSION} dist/inkstitch.app/Contents/Info.plist
    rm -rf dist/inkstitch/
    # Install location for pkgbuild
    PKG_INSTALL_PATH="/tmp/inkstitch/"

    # inside the scripts folder are:
    # - preinstaller (checks for previously installed inkstitch and deletes it, Inkscape check with error message) and
    # - postinstaller (moves inkstitch folder from /tmp to user Inkscape extensions folder in $HOME)
    # The postinstaller is a workaround for a proper way to install in user $HOME space

    # Build on GitHub will be handled differently from local builds.
    # Local builds will not be signed nor notarized. They are run to produce releases for legacy versions of macOS.
    # Notarization for development branches can be forced with this variable set to true
    NOTARIZE_DEVELOPMENT_BUILDS=false

    if [[ ! -z "${GITHUB_REF}" ]]; then
        # This code signs and notarize the inkstitch.app
        DEV_IDENT="Developer ID Application: Lex Neva (929A568N58)"
        echo "Signing of inkstitch.app"
        # signing the binary may fix notary issue
        /usr/bin/codesign -s "${DEV_IDENT}" \
                        --deep \
                        --force \
                        --entitlements installer_scripts/entitlements.plist \
                        -o runtime \
                        --timestamp \
                        dist/inkstitch.app/Contents/MacOS/inkstitch -v
        # last signing before packaging
        /usr/bin/codesign -s "${DEV_IDENT}" \
                        --deep \
                        --force \
                        --entitlements installer_scripts/entitlements.plist \
                        -o runtime \
                        --timestamp \
                        dist/inkstitch.app -v
        echo "Running pkgbuild"
        INSTALLER_IDENT="Developer ID Installer: Lex Neva (929A568N58)"
        /usr/bin/pkgbuild --root dist/inkstitch.app \
                        -s "${INSTALLER_IDENT}" \
                        --ownership recommended \
                        --identifier org.inkstitch.installer \
                        --version ${VERSION} \
                        --scripts installer_scripts/scripts \
                        --install-location ${PKG_INSTALL_PATH}inkstitch.app \
                        artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg
        if [[ "${GITHUB_REF}" =~ ^refs/tags/v[0-9.]+ || $NOTARIZE_DEVELOPMENT_BUILDS == true ]]; then
            echo "Notary starting"
            echo "Adding keychain item for notarytool"
            xcrun notarytool store-credentials "inkstitch-profile"  \
                                                --apple-id "${NOTARY_ACCOUNT}" \
                                                --team-id '929A568N58' \
                                                --password "${NOTARY_PASSWORD}"
            echo "Invoking notary process"
            xcrun notarytool submit -f json --wait \
                                    --keychain-profile "inkstitch-profile" \
                                    artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg 2>&1 | tee /tmp/notarization_info.json
            echo "Stapling the pkg for release"
            xcrun stapler staple artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg
            echo "Fetching the Notary Log"
            # code snippet is from https://github.com/ddev/signing_tools/blob/master/macos_notarize.sh
            status=$(jq -r .status </tmp/notarization_info.json)
            id=$(jq -r .id </tmp/notarization_info.json)
            echo "status=${status} id=${id}"
            xcrun notarytool log --apple-id "${NOTARY_ACCOUNT}" --team-id '929A568N58'  --password "${NOTARY_PASSWORD}" ${id} -f json >/tmp/notarization_log.json
            issues=$(jq -r .issues </tmp/notarization_log.json)
            if [ "$issues" != "null" ]; then
                printf "There are issues with the notarization (${issues})\n"
                printf "=== Log output === \n$(cat /tmp/notarization_log.json)\n"
                exit 7;
            fi;
        fi
    else
        # local builds will not be signed or notarized
        pkgbuild --root dist/inkstitch.app \
                --ownership recommended \
                --identifier org.inkstitch.installer \
                --version ${VERSION} \
                --scripts installer_scripts/scripts \
                --install-location ${PKG_INSTALL_PATH}inkstitch.app \
                artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg
    fi
    # Creating the zip for Drag n' Drop install
    cd dist
    7z a ../artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.zip *
    cd ..
else
    cp -a addons palettes symbols fonts tiles dbus inx LICENSE VERSION dist/inkstitch
    cp -a icons locales print dist/inkstitch/bin
fi

if [ "$BUILD" = "windows" ]; then
    # build the installer locally
    # remotely it will be called through build.yml after signing
    if [[ -z "${GITHUB_REF}" ]]; then
        bash bin/build-windows-installer
    fi
fi

if [ "$BUILD" = "linux" ] || [ "$BUILD" = "linux32" ]; then
    if [[ "$VERSION" =~ ^v[0-9][.0-9]+$ ]]; then
        VERSION=${VERSION#v}
    else
        # dpkg requires versions to start with a number, so we have to add
        # 0.0.1 for development builds
        VERSION="0.0.1-${VERSION}"
    fi

    ### RPM signing setup

    # Create or update the .rpmmacros file, prefer to use the INKSTITCH_GPG_KEY
    #    %_gpg_path /etc/rpm/.gpg   # ? not sure if this is needed
    #    %_gpg_name ID              # required for rpm signing
    #    %__gpg /usr/bin/gpg        # required for rpm signing

    retrieve_gpg_key_id

    GPG_EXEC=$(command -v gpg || command -v gpg2)  # 'command' bash built-in to find executable path

    echo "Creating/updating $HOME/.rpmmacros file..."
    cat <<EOF > "$HOME/.rpmmacros"
%__gpg $GPG_EXEC
%_gpg_name $GPG_KEY_ID
%_signature gpg
EOF
    echo "$HOME/.rpmmacros has been updated with key ID: $GPG_KEY_ID"

    # set the rpm file name for cpu arch
    if [[ "$BUILD" = "linux32" ]]; then
        linux_arch="i386"
    else
        linux_arch=${ARCH}
    fi

    echo "Creating deb"
    deb_version="$(sed -E 's/[^a-zA-Z0-9.+]/./g' <<< "$VERSION")"
    fpm -s dir \
        -t deb \
        -n inkstitch \
        -v "$deb_version" \
        -d "inkscape >= 1.0.0" \
        --deb-compression xz \
        --license "GPL-3.0" \
        --description "An open-source machine embroidery design platform based on Inkscape" \
        --url "https://inkstitch.org" \
        --maintainer "maintainer@inkstitch.org" \
        --after-install bin/after-install \
        --before-remove bin/before-remove \
        --verbose \
        dist/inkstitch=/opt

    echo "Creating rpm"
    fpm -s dir \
        -t rpm \
        -n inkstitch \
        -v "$VERSION" \
        -d "inkscape >= 1.0.0" \
        -a "$linux_arch" \
        --rpm-compression xz \
        --license "GPL-3.0" \
        --description "An open-source machine embroidery design platform based on Inkscape" \
        --url "https://inkstitch.org"  \
        --maintainer "maintainer@inkstitch.org" \
        --after-install bin/after-install \
        --before-remove bin/before-remove \
        --verbose \
        dist/inkstitch=/opt

    rpmsign --addsign inkstitch*.rpm
    mv inkstitch*.deb inkstitch*.rpm artifacts/

    # set file name for each cpu arch
    if [[ "$BUILD" = "linux32" ]]; then
        tar -C dist -Jcf artifacts/inkstitch-${VERSION}-${OS}-i386.tar.xz inkstitch
        cat "$(dirname "$0")/linux-sh-installer" artifacts/inkstitch-${VERSION}-${OS}-i386.tar.xz > artifacts/inkstitch-${VERSION}-${OS}-i386.sh
    else
        tar -C dist -Jcf artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.tar.xz inkstitch
        cat "$(dirname "$0")/linux-sh-installer" artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.tar.xz > artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.sh
    fi
fi
