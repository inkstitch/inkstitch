#!/bin/bash

# - assumes that the script is run from the root of the repository
# - assumes that the script is run with the:
#   - BUILD variable set to the target OS (osx, linux, linux32, windows)
#   - GITHUB_REF variable set to the current branch or tag
#   - VERSION variable set to the current version (optional, defaults to branch name)
#   - INKSTITCH_GPG_KEY variable set to the GPG key (optional, defaults to generating a new key)
#   - NOTARY_ACCOUNT and NOTARY_PASSWORD variables set for macOS notarization (optional, defaults to not notarizing)
#   - fpm and rpmsign tools installed for Linux builds
#   - pyinstaller tool installed for building Python applications
#   - jq tool installed for parsing JSON

MY_VERBOSITY_LOG_LEVEL=${MY_VERBOSITY_LOG_LEVEL:'1'}  # Default level is 1 (INFO)

if [[ "$MY_VERBOSITY_LOG_LEVEL" -ge 2 ]]; then
    set -x
fi

set -e

echo "------------------------------------------------- build-distribution-archives.sh"

if [[ -z "$BUILD" ]]; then
  echo "Error: BUILD variable is not set."
  exit 1
fi

INITIAL_SET_E_STATUS=0
case "$-" in *e*) INITIAL_SET_E_STATUS=1 ;; esac  # check if -e is set and save the status

# check output directory
if [[ ! -d "artifacts" ]]; then
    mkdir -p artifacts
fi

# TODO: use REF_NAME instead of GITHUB_REF
echo "GITHUB_REF=${GITHUB_REF}"
echo "GITHUB_REF_NAME=${GITHUB_REF_NAME}"
echo "OS=${OS}"
echo "VERSION=${VERSION}"
echo "--------------------------------------------------------- evaluating variables"

VERSION="${VERSION:-$(echo ${GITHUB_REF} | sed -e 's|refs/heads/||' -e 's|refs/tags/||' -e 's|/|-|g')}"
# if VERSION is not set, use the current branch name (what if detached HEAD?)
if [[ -z "$VERSION" ]]; then
    echo "Error: VERSION variable is not set."
    VERSION="$(git rev-parse --abbrev-ref HEAD | tr / - | tr '[:upper:]' '[:lower:]')"
fi
# uname returns the OS name, e.g. Linux, Darwin, etc. - that require lowercase
OS=$(echo ${BUILD:-$(uname)} | tr '[:upper:]' '[:lower:]')
ARCH="$(uname -m)"

echo "MY_USE_AUTHORIZED_SIGNING=${MY_USE_AUTHORIZED_SIGNING}"
echo "BUILD=${BUILD}"
echo "ARCH=${ARCH}"
echo "OS=${OS}"
echo "VERSION=${VERSION}"  # may be set by the Makefile otherwise empty ??? why
echo "---------------------------------------------------------------"

# ----------------------------------------------------------------
### *** GPG KEY SETUP ***

# Usage of GPG keys, simple  examples:
#   Listing GPG keys:
#     gpg --list-keys          or   gpg -k
#     gpg --list-secret-keys   or   gpg -K
#   Removing keys:
#     gpg --delete-key           or   gpg --delete-secret-key
#     just simply delete directory ~/.gnupg - this will remove all keys, make backup first

# Set the GPG key name for RPM packages
# Guaranteed invalid email address for temporary key @invalid.com
GPG_KEY_NAME="Temporary Inkstitch Build Key (Automated CI/CD Only) <inkstitch@invalid.com>"
# Initial GPG Key ID - in main branch secrets.
# This will be updated if a new key is generated.
GPG_KEY_ID="EA93BCE2CCD0FB2E77B2CC29E8120E50709E5C44"

# Function to generate a new GPG key
function generate_gpg_key() {
    echo "INKSTITCH_GPG_KEY variable is not set. Generating a new GPG key..."
    gpg --batch --full-generate-key <<EOF
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: $GPG_KEY_NAME
Name-Comment: Temporary RPM Signing Key for Ink/Stitch
Name-Email: inkstitch@invalid.com
Expire-Date: 0
%no-protection
%commit
EOF
    echo "New GPG key has been generated."
}

# This function retrieves the ID of the temporary GPG key. Search local GPG keyring for the key.
function get_gpg_key_id() {
    # Get the ID of the temporary key
    GENERATED_KEY_ID=$(gpg --list-secret-keys --with-colons "$GPG_KEY_NAME" | awk -F: '/^sec/{print $5; exit}')

    if [ -z "$GENERATED_KEY_ID" ]; then
        echo "Error: Failed to retrieve the ID of the temporary GPG key."
        exit 1
    fi

    # Update GPG_KEY_ID to match the newly generated key
    GPG_KEY_ID=$GENERATED_KEY_ID
    echo "Generated key ID: $GPG_KEY_ID"
}

# Retrieve the GPG key ID in variable GPG_KEY_ID
# This function checks if the MY_USE_AUTHORIZED_SIGNING variable.
#   true - it imports the key from the variable INKSTITCH_GPG_KEY.
#   flase - or not set, it checks for an existing key or generates a new one if necessary.
function retrieve_gpg_key_id() {

    if [[ "${MY_USE_AUTHORIZED_SIGNING}" == "true" ]]; then

        echo "Importing GPG key from INKSTITCH_GPG_KEY variable..."
        echo "$INKSTITCH_GPG_KEY" | base64 -d | gpg --import  # import to local GPG keyring
        echo "GPG key has been imported."

    else    #  Try local GPG key, if not set, try generate a new GPG key

        echo "Checking for existing GPG key..."
        if [ $INITIAL_SET_E_STATUS -eq 1 ]; then   # temporary disable -e if it was set
            set +e
        fi

        # try to get the key ID of the existing local temporary key
        gpg --list-secret-keys --keyid-format LONG "$GPG_KEY_NAME" &>/dev/null
        GPG_STATUS=$?

        if [ $INITIAL_SET_E_STATUS -eq 1 ]; then   # restore -e if it was set
            set -e
        fi


        if [[ $GPG_STATUS -eq 0 ]]; then
            echo "Found existing GPG key for user ID: $GPG_KEY_NAME"
            get_gpg_key_id  # Update GPG_KEY_ID to the existing key ID
        else
            echo "No existing GPG key found. Generating a new GPG key..."
            generate_gpg_key
            get_gpg_key_id  # Update GPG_KEY_ID after generating a new key
        fi

        echo "GPG key ID is set to: $GPG_KEY_ID"
    fi
}

### *** END GPG KEY SETUP ***

### --------------------------------------------------------------
### Start of the script

if [ "$BUILD" = "osx" ]; then
    cp -a addons icons locales print LICENSE VERSION palettes symbols fonts tiles dbus inx dist/inkstitch.app/Contents/Resources
    # adding version to Info.plist
    plutil -replace CFBundleShortVersionString -string ${VERSION} dist/inkstitch.app/Contents/Info.plist
    rm -rf dist/inkstitch/
    # Install location for pkgbuild
    PKG_INSTALL_PATH="/tmp/inkstitch/"

    # inside the scripts folder are:
    # - preinstaller (checks for previously installed inkstitch and deletes it, Inkscape check with error message) and
    # - postinstaller (moves inkstitch folder from /tmp to user Inkscape extensions folder in $HOME)
    # The postinstaller is a workaround for a proper way to install in user $HOME space

    # Build on GitHub will be handled differently from local builds.
    # Local builds will not be signed nor notarized. They are run to produce releases for legacy versions of macOS.
    # Notarization for development branches can be forced with this variable set to true
    NOTARIZE_DEVELOPMENT_BUILDS=false

    if [[ "${MY_USE_AUTHORIZED_SIGNING}" == "true" ]]; then
        # This code signs and notarize the inkstitch.app
        DEV_IDENT="Developer ID Application: Lex Neva (929A568N58)"
        echo "Signing of inkstitch.app"
        # signing the binary may fix notary issue
        /usr/bin/codesign -s "${DEV_IDENT}" \
                        --deep \
                        --force \
                        --entitlements installer_scripts/entitlements.plist \
                        -o runtime \
                        --timestamp \
                        dist/inkstitch.app/Contents/MacOS/inkstitch -v
        # last signing before packaging
        /usr/bin/codesign -s "${DEV_IDENT}" \
                        --deep \
                        --force \
                        --entitlements installer_scripts/entitlements.plist \
                        -o runtime \
                        --timestamp \
                        dist/inkstitch.app -v
        echo "Running pkgbuild"
        INSTALLER_IDENT="Developer ID Installer: Lex Neva (929A568N58)"
        /usr/bin/pkgbuild --root dist/inkstitch.app \
                        -s "${INSTALLER_IDENT}" \
                        --ownership recommended \
                        --identifier org.inkstitch.installer \
                        --version ${VERSION} \
                        --scripts installer_scripts/scripts \
                        --install-location ${PKG_INSTALL_PATH}inkstitch.app \
                        artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg
        # if [[ "${GITHUB_REF}" =~ ^refs/tags/v[0-9.]+ || $NOTARIZE_DEVELOPMENT_BUILDS == true ]]; then
        if true; then  # always notarize for now
            echo "Notary starting"
            echo "Adding keychain item for notarytool"
            xcrun notarytool store-credentials "inkstitch-profile"  \
                                                --apple-id "${NOTARY_ACCOUNT}" \
                                                --team-id '929A568N58' \
                                                --password "${NOTARY_PASSWORD}"
            echo "Invoking notary process"
            xcrun notarytool submit -f json --wait \
                                    --keychain-profile "inkstitch-profile" \
                                    artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg 2>&1 | tee /tmp/notarization_info.json
            echo "Stapling the pkg for release"
            xcrun stapler staple artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg
            echo "Fetching the Notary Log"
            # code snippet is from https://github.com/ddev/signing_tools/blob/master/macos_notarize.sh
            status=$(jq -r .status </tmp/notarization_info.json)
            id=$(jq -r .id </tmp/notarization_info.json)
            echo "status=${status} id=${id}"
            xcrun notarytool log --apple-id "${NOTARY_ACCOUNT}" --team-id '929A568N58'  --password "${NOTARY_PASSWORD}" ${id} -f json >/tmp/notarization_log.json
            issues=$(jq -r .issues </tmp/notarization_log.json)
            if [ "$issues" != "null" ]; then
                printf "There are issues with the notarization (${issues})\n"
                printf "=== Log output === \n$(cat /tmp/notarization_log.json)\n"
                exit 7;
            fi;
        fi
    else # Not using authorized signing keys, likely a Dev or Local Build
        # local builds will not be signed or notarized
        pkgbuild --root dist/inkstitch.app \
                --ownership recommended \
                --identifier org.inkstitch.installer \
                --version ${VERSION} \
                --scripts installer_scripts/scripts \
                --install-location ${PKG_INSTALL_PATH}inkstitch.app \
                artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.pkg
    fi
    # Creating the zip for Drag n' Drop install
    cd dist
    7z a ../artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.zip *
    cd ..
else
    cp -a addons palettes symbols fonts tiles dbus inx LICENSE VERSION dist/inkstitch
    cp -a icons locales print dist/inkstitch/bin
fi

if [ "$BUILD" = "windows" ]; then
    # build the installer locally
    # remotely it will be called through build.yml after signing
    if [[ -z "${GITHUB_REF}" ]]; then
        bash bin/build-windows-installer
    fi
fi

if [ "$BUILD" = "linux" ] || [ "$BUILD" = "linux32" ]; then
    if [[ "$VERSION" =~ ^v[0-9][.0-9]+$ ]]; then
        VERSION=${VERSION#v}
    else
        # dpkg requires versions to start with a number, so we have to add
        # 0.0.1 for development builds
        VERSION="0.0.1-${VERSION}"
    fi

    ### RPM signing setup

    # Create or update the .rpmmacros file, prefer to use the INKSTITCH_GPG_KEY
    #    %_gpg_path /etc/rpm/.gpg   # ? not sure if this is needed
    #    %_gpg_name ID              # required for rpm signing
    #    %__gpg /usr/bin/gpg        # required for rpm signing

    retrieve_gpg_key_id

    GPG_EXEC=$(command -v gpg || command -v gpg2)  # 'command' bash built-in to find executable path

    echo "Creating/updating $HOME/.rpmmacros file..."
    cat <<EOF > "$HOME/.rpmmacros"
%__gpg $GPG_EXEC
%_gpg_name $GPG_KEY_ID
%_signature gpg
EOF
    echo "$HOME/.rpmmacros has been updated with key ID: $GPG_KEY_ID"

    # set the rpm file name for cpu arch
    if [[ "$BUILD" = "linux32" ]]; then
        linux_arch="i386"
    else
        linux_arch=${ARCH}
    fi

    echo "Creating deb"
    deb_version="$(sed -E 's/[^a-zA-Z0-9.+]/./g' <<< "$VERSION")"

    # TODO: fpm is slow, consider using cmake to create deb and rpm packages

    # create deb package in ROOT of the repository
    # -s dir - source type is directory
    # -t deb - target type is debian package
    # -n inkstitch - package name
    # -v "$deb_version" - package version
    # -d "inkscape >= 1.0.0" - package dependency
    # --deb-compression xz - use xz compression for deb package
    # --license "GPL-3.0" - license for the package
    # --description "An open-source machine embroidery design platform based on Inkscape" - package description
    # --url "https://inkstitch.org" - package URL
    # --maintainer "maintainer@inkstitch.org" - package maintainer
    # --after-install bin/after-install - script to run after installation
    # --before-remove bin/before-remove - script to run before removal
    # --verbose - verbose output
    # dist/inkstitch=/opt - copy dist/inkstitch directory to /opt in the package
    fpm -s dir \
        -t deb \
        -n inkstitch \
        -v "$deb_version" \
        -d "inkscape >= 1.0.0" \
        --deb-compression xz \
        --license "GPL-3.0" \
        --description "An open-source machine embroidery design platform based on Inkscape" \
        --url "https://inkstitch.org" \
        --maintainer "maintainer@inkstitch.org" \
        --after-install bin/after-install \
        --before-remove bin/before-remove \
        --verbose \
        dist/inkstitch=/opt

    echo "Creating rpm"
    # create rpm package in ROOT of the repository
    # -t rpm - target type is rpm package
    fpm -s dir \
        -t rpm \
        -n inkstitch \
        -v "$VERSION" \
        -d "inkscape >= 1.0.0" \
        -a "$linux_arch" \
        --rpm-compression xz \
        --license "GPL-3.0" \
        --description "An open-source machine embroidery design platform based on Inkscape" \
        --url "https://inkstitch.org"  \
        --maintainer "maintainer@inkstitch.org" \
        --after-install bin/after-install \
        --before-remove bin/before-remove \
        --verbose \
        dist/inkstitch=/opt

    # Sign the rpm packages (in place?)
    rpmsign --addsign inkstitch*.rpm

    # Move the deb and rpm packages from ROOT to artifacts directory
    mv inkstitch*.deb inkstitch*.rpm artifacts/

    # Create the tar.xz archive for Linux and Linux32 builds from
    # tar - create an archive from dist/inkstitch directory and save it to artifacts
    #   -C dist  - change to dist directory, output is relative to this dir
    # cat - create self-extracting script for Linux
    #   - $(dirname "$0") - search for the linux-sh-installer script in the same directory as this script

    # TODO: use linux_arch instead of hardcoding i386 for linux32 builds
    if [[ "$BUILD" = "linux32" ]]; then
        tar -C dist -Jcf artifacts/inkstitch-${VERSION}-${OS}-i386.tar.xz inkstitch
        cat "$(dirname "$0")/linux-sh-installer" artifacts/inkstitch-${VERSION}-${OS}-i386.tar.xz > artifacts/inkstitch-${VERSION}-${OS}-i386.sh
    else
        tar -C dist -Jcf artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.tar.xz inkstitch
        cat "$(dirname "$0")/linux-sh-installer" artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.tar.xz > artifacts/inkstitch-${VERSION}-${OS}-${ARCH}.sh
    fi
fi


echo "------------------------------------------------- build-distribution-archives.sh done"