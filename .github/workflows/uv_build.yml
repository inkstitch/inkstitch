
# Action description:
#   https://docs.github.com/en/actions

name: UV Build

# Inputs (some selected):
#   GITHUB_EVENT_NAME - the name of the event that triggered the workflow (e.g., push, pull_request, workflow_dispatch, etc.)
#   GITHUB_REF_TYPE - the type of ref that triggered the workflow (e.g., branch, tag)
#   GITHUB_REF - what triggered the workflow (e.g., refs/heads/branch_name, refs/tags/v1.0.0, refs/)
#   GITHUB_REF_NAME - the name of the branch or tag that triggered the workflow (e.g., branch_name, v1.0.0)
#   GITHUB_SHA - the commit SHA that triggered the workflow
#   GITHUB_WORKSPACE - the path to the repository on the runner . top level directory of the repository

# on:
#   GITHUB_EVENT_NAME
#     GITHUB_REF_TYPE

# !!! important:
#   - A single tag can point to multiple branches, so there isn't a single matching branch for a tag.
#   - deafult branch for workflow_dispatch is the default branch of the repository, which is usually 'main' or 'master'.
#     - may be set gh workflow run -r <branch> <workflow_file>
#   - variables ${{ xxx }} are parsed by YAML parser, before shell can see it ( eg ${{ $xxx }} is not what you expect).

on:
  push: # at least ones must be triggered by a push to be available for manual trigger

    tags:         # EVENT_NAME=push              REF_TYPE=tag      REF=refs/tags/build*        REF_NAME=tag_name
      - build*    # build[optional characters]
      - v[0-9]+.[0-9]+.[0-9]+*  # v[digits].[digits].[digits][optional characters]

    # branches:   # EVENT_NAME=push              REF_TYPE=branch   REF=refs/heads/branch_name  REF_NAME=branch_name
    #   - missing/*  # branch pattern **= any number of characters and /, * = any number of characters not including /

  workflow_dispatch:  # manual trigger of the workflow
    inputs:
      # input variables for manual run
      build_type:                   # ref: github.event.inputs.build_type | inputs.build_type
        description: 'Build type'
        required: true
        default: 'linux64'  # default value
        type: choice  # type of the input, can be number, boolean, string, choice or environment
        options:
          - linux64
          # - linux32
          - linux-arm64
          # - linux-arm32

          - windows64
          # - windows32
          # - windows-arm64
          # - windows-arm32

          # - darwin64
          # - darwin32
          # - darwin-arm64
          # - darwin-arm32

          # - macos64
          # - macos32
          # - macos-arm64
          # - macos-arm32

          - all


      break_on:     # ref: github.event.inputs.break_on | inputs.break_on
        description: 'Stop the build immediately at a predefined location.'
        required: true
        default: 'no'  # default value
        type: choice  # type of the input, can be number, boolean, string, choice or environment
        options:
          - 'no'    # normal build
          - 'uv'    # stop the build at the uv venv creation step


# working example: ----------------------------------------------------------
jobs:

  # just info print
  # https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs#context-availability
  dump_contexts_to_log:
    runs-on: ubuntu-latest
    steps:
      - name: Dump environment variables
        run: printenv | sort    # or just `env` to print all environment variables

      - name: Dump GitHub context (github...)
        run: echo "${{ toJson(github) }}"

      - name: Dump job context (job...)
        run: echo "${{ toJson(job) }}"

      - name: Dump steps context (steps...)
        run: echo "${{ toJson(steps) }}"

      - name: Dump runner context (runner...)
        run: echo "${{ toJson(runner) }}"

      - name: Dump strategy context (strategy...)
        run: echo "${{ toJson(strategy) }}"

      - name: Dump matrix context
        run: echo "${{ toJson(matrix) }}"



  # Prepare data
  # - MY_BUILD_TYPE: type of build
  # - MY_BREAK_ON: define break stop

  # - MY_SELF_SIGNED: false/true - if we have access to secrets, or we use on the fly signed keys
  # - MY_TAG_NAME: tag name for the release, or dev-build-branch_name for pre-release
  # - MY_PRERELEASE: false/true - if this is a release or pre-release
  # - MY_NAME: name of the release

  sign_policy:
    runs-on: ubuntu-latest
    outputs:
      MY_BUILD_TYPE: ${{ steps.set_vars.outputs.MY_BUILD_TYPE }}
      MY_BREAK_ON: ${{ steps.set_vars.outputs.MY_BREAK_ON }}

      MY_SELF_SIGNED: ${{ steps.set_vars.outputs.MY_SELF_SIGNED }}
      MY_TAG_NAME: ${{ steps.set_vars.outputs.MY_TAG_NAME }}
      MY_PRERELEASE: ${{ steps.set_vars.outputs.MY_PRERELEASE }}
      MY_NAME: ${{ steps.set_vars.outputs.MY_NAME }}
    # if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set sign policy variables
        id: set_vars
        shell: bash
        run: |

          echo "-------------------------------------------------"
          echo "Set signing policy variables ..."
          echo secrets.GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # print ***, always set

          echo "-------------------------------------------------"

          # this is just for testing, not needed in real workflow on github (with enough rights)
          echo "Testing secrets:"
          echo secrets.INKSTITCH_GPG_KEY: ${{ secrets.INKSTITCH_GPG_KEY }} # print *** if available

          echo "-------------------------------------------------"
          # inputs
          echo "Inputs:"
          echo "${{ toJSON(github.event.inputs) }}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              # If so, use the values from the inputs
            MY_BUILD_TYPE="${{ github.event.inputs.build_type }}"
            MY_BREAK_ON="${{ github.event.inputs.break_on }}"
          else
            # If not (i.e. it's a push or other event), use the defaults
            MY_BUILD_TYPE="linux64"   # all
            MY_BREAK_ON="uv"          # no
          fi

          echo "-------------------------------------------------"
          # Check if secrets are available
          if [[ -n "${{ secrets.INKSTITCH_GPG_KEY }}" ]]; then
            MY_SELF_SIGNED=false      # we have access to secrets, assume all signing keys are available
          else
            MY_SELF_SIGNED=true       # we use on the fly signed keys
          fi

          echo "-------------------------------------------------"

          # *** release requires tag name
          # if push tag vX.X.X - release sign-policy,
          if [[ "${GITHUB_EVENT_NAME}" == "push" && \
                "${GITHUB_REF_TYPE}" == "tag" && \
                "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+.* ]]; then
            MY_TAG_NAME="${GITHUB_REF_NAME}"
            MY_PRERELEASE=false  # we are creating a release
            MY_NAME="${MY_TAG_NAME}"
          else
            MY_TAG_NAME="dev-build-$(echo $GITHUB_REF_NAME | tr / -)"  # use branch/tag name as tag, replace / with -
            MY_PRERELEASE=true   # we are creating a pre-release
            MY_NAME="${MY_TAG_NAME}"
          fi

          # For Release (MY_PRERELEASE==false) we need access to secrets, if not (MY_SELF_SIGNED==true) exit with error
          if [[ "${MY_PRERELEASE}" == "false" && "${MY_SELF_SIGNED}" == "true" ]]; then
            echo "Error: Cannot create a release without access to secrets."
            exit 1
          fi


          echo "------------------------------------------------- echoing variables"
          echo "MY_BUILD_TYPE=${MY_BUILD_TYPE}"
          echo "MY_BREAK_ON=${MY_BREAK_ON}"

          echo "MY_SELF_SIGNED=${MY_SELF_SIGNED}"
          echo "MY_TAG_NAME=${MY_TAG_NAME}"
          echo "MY_PRERELEASE=${MY_PRERELEASE}"
          echo "MY_NAME=${MY_NAME}"

          echo "------------------------------------------------- Exporting variables to GITHUB_OUTPUT"
          echo "MY_BUILD_TYPE=${MY_BUILD_TYPE}" >> $GITHUB_OUTPUT
          echo "MY_BREAK_ON=${MY_BREAK_ON}" >> $GITHUB_OUTPUT

          echo "MY_SELF_SIGNED=${MY_SELF_SIGNED}" >> $GITHUB_OUTPUT
          echo "MY_TAG_NAME=${MY_TAG_NAME}" >> $GITHUB_OUTPUT
          echo "MY_PRERELEASE=${MY_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "MY_NAME=${MY_NAME}" >> $GITHUB_OUTPUT

          echo "------------------------------------------------- dump GITHUB_* part of env"
          env | grep GITHUB_ | sort

  # -----------------------------------------------------

  # !!! reusable must be on job level & .yml must be on top level of .github/workflows/
  linux64_build:
    needs: sign_policy # this job depends on the sign_policy job
    if: >
      needs.sign_policy.outputs.MY_BUILD_TYPE == 'linux64' ||
      needs.sign_policy.outputs.MY_BUILD_TYPE == 'all'
    name: Build Linux64
    uses: ./.github/workflows/uv_build_linux64.yml # call reusable workflow
    with:
      break_on: ${{ needs.sign_policy.outputs.MY_BREAK_ON }} # set input variable for the reusable workflow
      self_signed: ${{ needs.sign_policy.outputs.MY_SELF_SIGNED }}
    secrets:
      INKSTITCH_GPG_KEY: ${{ secrets.INKSTITCH_GPG_KEY}}


  linux_arm64_build:
    needs: sign_policy # this job depends on the sign_policy job
    if: >
      needs.sign_policy.outputs.MY_BUILD_TYPE == 'linux-arm64' ||
      needs.sign_policy.outputs.MY_BUILD_TYPE == 'all'
    name: Build Linux-arm64
    uses: ./.github/workflows/uv_build_linux-arm64.yml # call reusable workflow
    with:
      break_on: ${{ needs.sign_policy.outputs.MY_BREAK_ON }} # set input variable for the reusable workflow
      self_signed: ${{ needs.sign_policy.outputs.MY_SELF_SIGNED }}


  windows64_build:
    needs: sign_policy # this job depends on the sign_policy job
    if: >
      needs.sign_policy.outputs.MY_BUILD_TYPE == 'windows64' ||
      needs.sign_policy.outputs.MY_BUILD_TYPE == 'all'
    name: Build Windows64
    uses: ./.github/workflows/uv_build_windows64.yml # call reusable workflow
    with:
      break_on: ${{ needs.sign_policy.outputs.MY_BREAK_ON }} # set input variable for the reusable workflow
      self_signed: ${{ needs.sign_policy.outputs.MY_SELF_SIGNED }}


  #----------------------------------------------------


  release:
    runs-on: ubuntu-latest
    needs:  # wait for all builds to finish
      - linux64_build
      - linux_arm64_build
      - windows64_build
    if: always() # run this job always, even if previous jobs failed on exit 1

    steps:
      # get files from artifacts
      # - name: Download artifacts from build job
      #   uses: actions/download-artifact@v4    # https://github.com/actions/download-artifact
      #   with:
      #   #   name: .. # default is all artifacts
      #     path: artifacts  # download to artifacts directory


      - name: List files in artifacts directory
        shell: bash
        run: |

          echo "Listing files in artifacts directory:"
          ls -lR artifacts
